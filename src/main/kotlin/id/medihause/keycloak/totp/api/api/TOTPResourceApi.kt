package id.medihause.keycloak.totp.api.api

import id.medihause.keycloak.totp.api.dto.CommonApiResponse
import id.medihause.keycloak.totp.api.dto.GenerateTOTPResponse
import id.medihause.keycloak.totp.api.dto.RegisterTOTPCredentialRequest
import id.medihause.keycloak.totp.api.dto.VerifyTOTPRequest
import jakarta.ws.rs.*
import jakarta.ws.rs.core.MediaType
import jakarta.ws.rs.core.Response
import org.keycloak.models.KeycloakSession
import org.keycloak.models.UserCredentialModel
import org.keycloak.models.UserModel
import org.keycloak.models.credential.OTPCredentialModel
import org.keycloak.models.utils.Base32
import org.keycloak.models.utils.HmacOTP
import org.keycloak.models.utils.TimeBasedOTP
import org.keycloak.services.managers.AppAuthManager
import org.keycloak.utils.CredentialHelper
import org.keycloak.utils.TotpUtils
import java.util.Arrays

class TOTPResourceApi(
    private val session: KeycloakSession,
) {

    // -------- Helpers (responses) --------

    private fun ok(msg: String) =
        Response.ok().entity(CommonApiResponse(msg)).build()

    private fun badRequest(msg: String) =
        Response.status(Response.Status.BAD_REQUEST).entity(CommonApiResponse(msg)).build()

    private fun notFound(msg: String = "Not found") =
        Response.status(Response.Status.NOT_FOUND).entity(CommonApiResponse(msg)).build()

    private fun conflict(msg: String) =
        Response.status(Response.Status.CONFLICT).entity(CommonApiResponse(msg)).build()

    private fun unauthorized(msg: String = "Unauthorized") =
        Response.status(Response.Status.UNAUTHORIZED).entity(CommonApiResponse(msg)).build()

    // -------- Auth / User resolution --------

    private fun authenticateSessionAndGetUser(userId: String): UserModel {
        val auth = AppAuthManager.BearerTokenAuthenticator(session).authenticate()
            ?: throw NotAuthorizedException("Token not valid")

        // Only service accounts can use this API
        if (auth.user.serviceAccountClientLink == null) {
            throw NotAuthorizedException("User is not a service account")
        }

        // Require realm role
        val realmAccess = auth.token.realmAccess
        if (realmAccess == null || !realmAccess.isUserInRole("manage-totp")) {
            throw NotAuthorizedException("Forbidden")
        }

        val realm = session.context.realm

        val user = session.users().getUserById(realm, userId)
            ?: throw NotFoundException("Not found")

        // Don't allow managing service accounts
        if (user.serviceAccountClientLink != null) {
            throw BadRequestException("Cannot manage service account")
        }

        return user
    }

    // -------- OTP policy / secret length --------

    private fun secretLengthFromRealmPolicy(): Int {
        // Align secret size with hash output size when possible
        val algo = session.context.realm.otpPolicy.algorithm ?: "HmacSHA1"
        return when {
            algo.contains("SHA512", ignoreCase = true) -> 64
            algo.contains("SHA256", ignoreCase = true) -> 32
            else -> 20 // SHA1 / default
        }
    }

    // -------- Endpoints --------

    @GET
    @Path("/{userId}/generate")
    @Produces(MediaType.APPLICATION_JSON)
    fun generateTOTP(@PathParam("userId") userId: String): Response {
        val user = authenticateSessionAndGetUser(userId)
        val realm = session.context.realm

        val secretLength = secretLengthFromRealmPolicy()

        // Raw secret generated by Keycloak helper
        val rawSecret = HmacOTP.generateSecret(secretLength)

        // Expose to clients as Base32
        val encodedSecret = Base32.encode(rawSecret.toByteArray(Charsets.UTF_8))

        // QR Code based on the raw secret (Keycloak utility)
        val qrCode = TotpUtils.qrCode(rawSecret, realm, user)

        return Response.ok().entity(
            GenerateTOTPResponse(
                encodedSecret = encodedSecret,
                qrCode = qrCode
            )
        ).build()
    }

    @POST
    @Path("/{userId}/verify")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    fun verifyTOTP(request: VerifyTOTPRequest, @PathParam("userId") userId: String): Response {
        val user = authenticateSessionAndGetUser(userId)

        if (!VerifyTOTPRequest.validate(request)) {
            return badRequest("Invalid request")
        }

        val credentialModel = user.credentialManager().getStoredCredentialByNameAndType(
            request.deviceName,
            OTPCredentialModel.TYPE
        ) ?: return notFound() // anti-enumeration

        val otpCredential = OTPCredentialModel.createFromCredentialModel(credentialModel)
        val credentialId = otpCredential.id

        val isCredentialValid = user.credentialManager().isValid(
            UserCredentialModel(credentialId, OTPCredentialModel.TYPE, request.code)
        )

        return if (isCredentialValid) ok("TOTP code is valid") else unauthorized("Invalid TOTP code")
    }


    @POST
    @Path("/{userId}/register")
    @Consumes(MediaType.APPLICATION_JSON)
    @Produces(MediaType.APPLICATION_JSON)
    fun registerTOTP(request: RegisterTOTPCredentialRequest, @PathParam("userId") userId: String): Response {
        val user = authenticateSessionAndGetUser(userId)

        if (!RegisterTOTPCredentialRequest.validate(request)) {
            return badRequest("Invalid request")
        }

        val realm = session.context.realm
        val encodedSecret = request.encodedSecret

        // Base32 decode to validate secret and validate initial TOTP
        val secretBytes: ByteArray = try {
            Base32.decode(encodedSecret)
        } catch (e: Exception) {
            return badRequest("Invalid secret")
        }

        // Check existing credential
        val existingCredential = user.credentialManager().getStoredCredentialByNameAndType(
            request.deviceName,
            OTPCredentialModel.TYPE
        )

        if (existingCredential != null && !request.overwrite) {
            Arrays.fill(secretBytes, 0.toByte())
            return conflict("TOTP credential already exists")
        }

        // Validate initial TOTP using realm policy
        val totp = TimeBasedOTP(
            realm.otpPolicy.algorithm,
            realm.otpPolicy.digits,
            realm.otpPolicy.period,
            realm.otpPolicy.lookAheadWindow
        )

        val isInitialCodeValid: Boolean = try {
            totp.validateTOTP(request.initialCode, secretBytes)
        } finally {
            Arrays.fill(secretBytes, 0.toByte())
        }

        if (!isInitialCodeValid) {
            return badRequest("Invalid Initial TOTP")
        }

        // If overwrite, remove existing credential first (cleaner & avoids duplicates)
        if (existingCredential != null && request.overwrite) {
            user.credentialManager().removeStoredCredentialById(existingCredential.id)
        }

        val totpCredentialModel = OTPCredentialModel.createFromPolicy(realm, encodedSecret, request.deviceName)

        val ok = CredentialHelper.createOTPCredential(session, realm, user, request.initialCode, totpCredentialModel)

        // sometime Keycloak return false event if credential is created. To handle this, double check if credential was created and return success if yes
        if (!ok) {
            val existsNow = user.credentialManager().getStoredCredentialByNameAndType(
                request.deviceName,
                OTPCredentialModel.TYPE
            ) != null

            if (existsNow) {
                //createOTPCredential returned false but credential exists; returning 201 anyway
                return Response.status(Response.Status.CREATED)
                    .entity(CommonApiResponse("TOTP credential registered"))
                    .build()
            }

            return Response.status(Response.Status.INTERNAL_SERVER_ERROR)
                .entity(CommonApiResponse("Failed to create TOTP credential"))
                .build()
        }

        return Response.status(Response.Status.CREATED)
            .entity(CommonApiResponse("TOTP credential registered"))
            .build()
    }
}
